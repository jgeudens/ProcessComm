# Journal

## Initial experiment (grpc and localhost) - C++

### General

* <https://doc.qt.io/qt-6/qtgrpc-index.html>
* Prerequisite
  * `sudo dnf install protobuf-compiler protobuf-devel`

### Code

   ```c++
   #include "echoclient.h"
   
   EchoClient::EchoClient(const QUrl& endpoint, QObject* parent) : QObject(parent)
   {
       m_channel = std::make_shared<QGrpcHttp2Channel>(endpoint);
       m_client = std::make_unique<echo::EchoService::Client>();
       m_client->attachChannel(m_channel);
   }
   
   void EchoClient::echo(const QString& message)
   {
       echo::EchoRequest request;
       request.setMessage(message);
   
       auto* reply = m_client->Echo(request).release();
   
       connect(
         reply, &QGrpcCallReply::finished, this,
         [this, reply](const QGrpcStatus& status) {
             if (status.isOk())
             {
                 const auto response = reply->read<echo::EchoReply>();
                 if (response.has_value())
                 {
                     emit echoSucceeded(response->message());
                 }
                 else
                 {
                     emit echoFailed(-1, QStringLiteral("Failed to read response"));
                 }
             }
             else
             {
                 emit echoFailed(static_cast<int>(status.code()), status.message());
             }
   
             reply->deleteLater();
         },
         Qt::SingleShotConnection);
   }
   ```

This method sends an asynchronous gRPC *Echo* request. It returns immediately and reports the result through Qt signals once the server responds.

#### 1. Build the gRPC request

```cpp
echo::EchoRequest request;
request.setMessage(message);
```

* `echo::EchoRequest` is the protobuf-generated request type.
* `setMessage()` is generated by QtGrpc and accepts a `QString`.
* QtGrpc maps `string` fields in `.proto` files to Qt-friendly types instead of `std::string`.

#### 2. Invoke the RPC asynchronously

```cpp
auto* reply = m_client->Echo(request).release();
```

* `m_client->Echo(request)` starts an asynchronous unary RPC.
* It returns a `std::unique_ptr<QGrpcCallReply>`.
* Calling `release()` transfers ownership to Qt and returns a raw pointer.

This is required because `QGrpcCallReply` is a `QObject`. Qt manages object lifetimes via its event loop, so RAII ownership with `std::unique_ptr` is intentionally abandoned here.

#### 3. Connect to the completion signal

```cpp
connect(
  reply, &QGrpcCallReply::finished, this,
  [this, reply](const QGrpcStatus& status) {
```

* The `finished` signal is emitted when the RPC completes.
* The lambda captures:
  * `this` to emit Qt signals
  * `reply` to read the response and delete it later
* The lambda runs in the Qt event loop thread.

#### 4. Check the gRPC call status

```cpp
if (status.isOk())
```

* `status.isOk()` indicates the RPC succeeded at the transport and server level.
* If false, the call failed due to timeout, network error, or server-side failure.

#### 5. Read the response message

```cpp
const auto response = reply->read<echo::EchoReply>();
```

* Attempts to deserialize the response message.
* Returns `std::optional<echo::EchoReply>` to account for decoding failures.

##### Successful response

```cpp
emit echoSucceeded(response->message());
```

* Extracts the `message` field from the response.
* Emits a success signal with the returned data.

##### Unexpected decode failure

```cpp
emit echoFailed(-1, QStringLiteral("Failed to read response"));
```

* Handles the rare case where the RPC succeeded but the response could not be parsed.
* Uses a sentinel error code to distinguish from gRPC status codes.

------

#### 6. Handle gRPC-level errors

```cpp
emit echoFailed(static_cast<int>(status.code()), status.message());
```

* Converts the gRPC status code to an integer.
* Emits a failure signal with the server-provided message.

#### 7. Clean up the reply object

```cpp
reply->deleteLater();
```

* `QGrpcCallReply` is a `QObject` and must be deleted via the Qt event loop.
* `deleteLater()` ensures safe destruction even if the signal is currently executing.

Direct deletion (`delete reply`) would be unsafe.

#### 8. Single-shot connection

```cpp
Qt::SingleShotConnection
```

* Ensures the slot is executed only once.
* Prevents accidental multiple invocations.
* Avoids use-after-free errors after `deleteLater()` is called.

#### Execution timeline

```text
echo() called
  → RPC sent
  → server processes request
  → finished() signal emitted
  → response read
  → success or failure signal emitted
  → reply scheduled for deletion
```

##  Initial experiment (grpc and localhost) - Python

* Generate
  * `python -m grpc_tools.protoc -I ../proto --python_out=. --grpc_python_out=. ../proto/echo.proto`
